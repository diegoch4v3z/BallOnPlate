Embedded Execution Engine
===========================



What is Embedded Execution Engine?
------------------------------------

Embedded Execution Engine(EEE) is a standalone binary which can be used to restore the execution state of the board from previosuly saved state.
As the name suggests, it is designed to work in embedded environment with minimal memory requirements. The Engine takes a json file and time-steps to be run as an input. It restores the execution state to one provided in the json file and runs the execution for
given time-steps. The json file captures the execution context and is generated by running generateEEEArtifact on the board. The artifacts generated on a particular platform is guaranteed to run only on the same platform.

Step by step guide on how to use Embedded Execution Engine:
------------------------------------------------------------

.. figure:: _static/eee.png
   :alt: EmbeddedExecutionEngine

1. Configure the network

.. code-block:: python

        def setupNetwork():
            net = nx.NxNet()
            p = nx.CompartmentPrototype(biasMant=100,
                                        biasExp=6,
                                        vThMant=1000,
                                        functionalState=2,
                                        compartmentVoltageDecay=256)

            # Create a compartment in the network using the prototype
            compartment = net.createCompartment(p)
            return net

2. Compile the network
    .. code-block:: python

        net = setupNetwork()
        compiler = nx.N2Compiler()
        board = compiler.compile(net)

3. Generate the EEE Artifact by calling generateEEEArtifacts on the board with the path
   of directory where artifacts should be generated.

.. code-block:: python

        # Generates the EEE Artifacts
        try:
            # Generates artifacts in artifacts folder located in file directory
            board.generateEEEArtifacts(os.path.join(os.path.dirname(os.path.realpath(__file__)),"artifacts"))
        finally:
            board.disconnect()

4. Json generated will look like this :

.. code-block:: json

    {
        "chipsRequired": 1,
        "lmtOptions": [],
        "datFile": "/home/yashward/Workspace/nxsdk-nxsdk/scratch/eee_tutorial/artifacts/boardDump.dat",
        "library": "",
        "options": [
            "epoch=0"
        ],
        "dvsMode": 0,
        "snipTuples": [],
        "channels": []
    }

5. Copy the artifact folder to the desired board or superhost in case of KB.
6. Change the path of binary, library and datFile in the json File.
7. Run embedded_execution_engine by passing jsonFile and timesteps as argument :

    ./embedded_execution_engine -c /path/to/json/file -t num_timesteps

Gotchas regarding using EEE
-----------------------------

1. Probing is ignored while generation of the EEE Artifcats and is not supported on EEE.
2. EEE doesn't have a superhost component. It runs purely on host.
3. Channels created for use in EEE should be between Host and Embedded. Channels are not
   supported between SuperHost and Embedded.
4. The artifacts generated on a particular platform is guaranteed to run only on the same platform.
   For e.g. : Host snips generated for x86(in case of KB) won't work on nahuku(arm host).

Description of Json Fields
----------------------------

1. **dvsMode** : DvsMode indicates the mode of operation of dvs and can be one of the following:

    DVS_DISABLE_MODE = 0

    DVS_DEFAULT_MODE = 1

    DVS_TEST_MODE = 2

2. **channels** : Channels consists of list of defined channel. Each channel structure has following fields:

    Name of the Channel : channelName
    Maximum number of elements : capacity
    Size of each element when being written/read : messageSize
    Direction of the channel : direction - 0 For Send 1 for Receive
    ChipId associated with this channel : chipId
    LmtId associated with this channel : coreId
    Slack associated with the channel : slack

3. **chipsRequired** : Chips required by the network

4. **datFile** : Location of the dat file

5. **library** : Location of the host snip library (*.so) file

6. **options** : List of options to be passed to the embedded Driver (for e.g. learning epoch)

7. **lmtOptions** : List of lmtOptions to be passed to the embedded Driver

8. **snipTuples** : List of snipTuple, consisting of chipId, lmtId and the location of the binary


